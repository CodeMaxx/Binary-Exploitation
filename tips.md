# Tips and Tricks

#### Finding string offsets for ret2libc attack

`strings -a -t x /lib32/libc-2.24.so | grep /bin/sh`

#### The ever forgetful `test` instruction

The TEST instruction performs a bitwise AND on two operands. The flags SF(Sign Flag a.k.a. Negative Flag), ZF(Zero Flag), PF(Parity Flag) are modified while the result of the AND is discarded. The OF(Overflow Flag) and CF(Carry Flag) flags are set to 0, while AF(Auxillary Carry Flag) flag is undefined. There are 9 different opcodes for the TEST instruction depending on the type and size of the operands. It can compare 8-bit, 16-bit, 32-bit or 64-bit values. It can also compare registers, immediate values and register indirect values.

The Sign Flag(Negative Flag) is set to the most significant **bit** of the result of the AND. In two's complement, a number with most significant bit = 1 is negative. If the result is 0, the Zero Flag is set to 1, otherwise 0. The Parity Flag is set to the bitwise XNOR of the least significant **BYTE** of the result i.e. if the number of 1s in the least significant byte is even, then the PF is set to 1 else 0.

#### Branch coverage v/s Statement coverage

Unless we consider `goto` as a branch, branch coverage doesn't imply statement coverage and vice-versa.

If we consider `goto` as a branch, then branch coverage implies statement coverage but not vice-versa(Even if we take **simple** statements).(Note that if we have a `goto` statement, then one branch will never be covered so we'll never have full branch coverage in case of a goto statement.
See the following example:

```
if(x)
  then S1;
 
S2;
```
So if `x=1`, then every statement gets covered but not every branch(the false branch).

Take a look at [this presentation](https://www.cs.drexel.edu/~jhk39/teaching/cs576su06/L4.pdf). Note that the numbers on the left show the order of execution for a certain input.

**Note:** Path coverage >= Branch coverage >= Statement coverage

#### Compound statement

```
if(x){
  S1;
  S2;
  S3;
}
```

This whole is a single compuound statement while S1, S2, S3 are simple statements.

#### Shellshock

`export x='() { :;}; echo $(/bin/cat /home/shellshock/flag)'`

The pattern `() { :;};` is the key!

Also see [this stackoverflow question](https://unix.stackexchange.com/questions/157329/what-does-env-x-command-bash-do-and-why-is-it-insecure) and [this video](https://www.youtube.com/watch?v=u1H12rMdLTg).

#### Common Bugs
- Broken input functions
  - scanf("%s") - Doesn't limit the size of the input, so you can overflow basically anything. It also taken in null bytes, only stops at whitespace. The problem is with the format string "%s" and not the scanf function per se. If you use "%100s" it will take in 100 characters only.
  - gets([char*]) - Here the problem is the function itself. It doesn't allow adding string length, so NEVER use this!
  
- String length mismatch
  - Constant length inconsistencies - 
  - strlen() vs counted length - Say you have a `#define Counted_Length 10` i.e. you know a string is 10 characters in length. But "null byte injection"! If you use `strlen()` somewhere and the string has a null byte then you will get a different value.
  - Counted length contradictions - This can be thought of with respect to the heartbleed bug. This occurs when you supply the length of a string at two different places but you don't check if the two values are equal.
  
- Off by One errors
  - 1-index/0-index - Remember to use the correct values in your `for` loops. First element of list is list[0]; Last element of a list is list[length-1], not list[length]. List[length] will give you the data in memory just after the list. Someone may have place some malicious data here.

- Numeric errors
  - negative negative 2^31 == negative 2^31 - Think of how -2^31 is represented in memory(It's all 1s. negating it means taking it's two's complement which is negative 2^31). You can bypass checks like `if(x == -x and x!=0)`! 
  - Up-casting **signed** numeric types, e.g. char -> int - Consider the following code:
  ```
    char input_data[20];
    char transformation[256];

    for(int i = 0; i < 20; i++) {
      input_data[i] = transformation[input_data[i]];
    }
  ```
  Now here you may assume that `input_data` being a char will be converted into an integer b/w 0 and 255. But this is not true. I am not sure if this is false all the time though. But to be safe you should use `unsigned char` in such cases where you think you'll be using it as an index later.
  - failing to account for overflow - assuming `y > 0 => x + y > x` is wrong since `x+y` may overflow the buffer and you might end up getting a smaller value than `x`.
  - floating point: Failing to account for inf and nan
  - floating point: Assuming x + 1 != x

- Order of operations errors
  - assignment expressions and ternary statements have extremely high precedence
  - Operator Priority (See `mistake` challenge on [pwnable.kr](pwnable.kr))

- User-controlled format strings
  - format string exploitation is a really strange and very powerful black magic. Gives you the power to read and write to memory at an address of your choice!
  - printf(variable) should be a huge red flag - Always pass the format string as the first argument to printf!

- Use after free
  - failure to clean up freed pointers
  - type confusion

- Improper sanitization, injection
  - Quotation breakout
  - Null bytes
  - Fail-check sanitization escape
  - Decoding after sanitization
  - Generally, using non-constant command strings is extremely dangerous

- Failure to check error conditions
  - malloc returns NULL on error - There is no crash at malloc but you may try to dereference the pointer somewhere. So whenever malloc-ing, do check if NULL is returned.
  - scanf returns number of filled out parameters - This is a fun one.
  - functions with buffers as outparams will leave the buffer unchanged on error, return -1
  - failure to check returned length (assuming maximum) can be a memory leak

#### Bypassing `/` filter

To Bypass `/` when PATH variable is empty, use `cd ..;cd ../; $(pwd)`. $(pwd) in root directory gives `/`

#### Finding GOT table address

`objdump -R [binary] | grep [function_name]`

#### Finding offset of a function in a library

`readelf -s [path/to/library.so] | grep [function_name]`

#### Getting executable from assembly

##### Assembling to object code
`nasm -f [output_file_format] [assembly_file.asm]`

##### Linking
`ld -o [outfile_name] [object_file.o]`

#### Extracting shellcode from executables
(Note that null bytes might be stripped in objdump)

``for i in `objdump -d print_flag | tr '\t' ' ' | tr ' ' '\n' | egrep '^[0-9a-f]{2}$' ` ; do echo -n "\x$i" ; done``
